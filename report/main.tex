\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
\usepackage{xspace}
\usepackage{graphicx} % For \includegraphics
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory
\usepackage{amsmath}
\bibliographystyle{plainurl}% the bibstyle
\usepackage{cleveref} % Provides \Cref
\usepackage{listings} % For code snippets


\title{Implementation and verification of an encoder decoder pair and generator for prefix-free codes}

\author{Samuel Chassot}{EPFL}{samuel.chassot@epfl.ch}{}{}
\author{Daniel Filipe Nunes Silva}{EPFL}{daniel.nunessilva@epfl.ch}{}{}

\authorrunning{S.~Chassot and D.~F.~Nunes~Silva}

\Copyright{Samuel Chassot and Daniel Filipe Nunes Silva}

\ccsdesc[500]{Software and its engineering~Software verification and validation}

\keywords{formal verification, prefix-free codes, Huffman Coding}

\category{}
\relatedversion{}
\supplement{}
\nolinenumbers 
\hideLIPIcs

\begin{document}

\maketitle

\begin{abstract}
    Prefix-free codes are widely used in communication systems, e.g. in compression algorithms combined with Huffman's algorithm. In this work, we propose an implementation in the Scala programming language of an encoder decoder pair as well as a naive prefix-free code generator. Such implementations can be critical due to the fundamental role they play. Therefore, our implementations are formally proven for correctness thanks to the verification framework Stainless \cite{stainless}. Those three functions can be chained to form a pipeline as a whole on a given input string $s$, i.e. generate a correspoding prefix-free code $c$, use $c$ to encode $s$ as $e$ and finally decode $e$ with $c$ as $d$. Correctness is therefore defined as $s == d$.
\end{abstract}

\definecolor{bgcolor}{RGB}{240,252,210}
\definecolor{kwcolor}{RGB}{0,0,200}
\lstdefinelanguage{scala}{
  keywordstyle=\color{kwcolor},
  backgroundcolor=\color{bgcolor},
  alsoletter={@,=,>},
  morekeywords={abstract, case, class, def,
        else, extends, false, free, if, implicit, match,
        object, true, val, var, while, sealed,
        for, dependent, null, type, with, try, catch, finally,
        import, final, return, new, override, this, trait,
        private, public, protected, package, throw},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  mathescape=true,
  %emph={Int,Char,Boolean,String,Unit},
  %emphstyle={\color{blue}}
}
\lstset{language=scala}


\section{Introduction}
\label{sec:intro}

The aim of this project is to come up with a verified implementation of an encoder decoder pair as well as a prefix-free code generator in the scope of a personal project for the Formal Verification course (CS-550) at EPFL.

In \cite{blanchette}, J. C. Blanchette presents a formal proof of the optimality for the Huffman's algorithm. The latter generates a prefix-free code for a string such that the encoding of the encoded string has minimal length. As proposed in the conclusion of Blanchette's article, we explore the verification of encode/decode functions.

In this report, we start with some background knowledge related to prefix-free codes. Then, we go through the verified implementation of the pipeline we propose.

\subsection*{Prior work}

To the best of our knowledge, this is the first time an encode/decode function pair is formally verified.
However we can find many examples of similar exercises in the litterature such as a formal definition Huffman's algorithm in \cite{formal} or a formally verified implemention of compression/decompression function pair for deflate in \cite{deflate}.

\subsection*{Our approach} % the star makes the section number disappear

We first consider the whole class of prefix-free codes and not only the optimal ones generated by Huffman's algorithm.
Then, we come up with basic datatypes and implementations in vanilla Scala before adding  \emph{require}s and \emph{ensuring}s from Stainless in order to validate the main correctness theorem.
Finally, we also implement and verify an naive prefix-free code generator in order to complete the whole pipeline.

\pagebreak

\subsection*{Contributions} % the star makes the section number disappear

The main contributions of this report are the following:
\begin{enumerate}
    \item a formally verified implementation of an encode decode pair for prefix-free codes
    \item a formally verified implementation of a prefix-free code generator
\end{enumerate}

\section{Implementation}

Our code is available in the following repository:
\begin{center}
    \url{https://github.com/samuelchassot/FormalVerification-PrefixFreeCodes}
\end{center}
and build instructions are in file \verb|README.md| in the top-level directory.

\section{Prefix-free codes}

We define a code as a map from characters formed from a string, the symbols, to a list of bits, the code words. The fact that a code is prefix-free means that there is no full code word in this map that is a prefix of an other code word, i.e. $01$ is a prefix of the code word $0111$.

Those codes can be represented as full binary trees. To determine the code word of a symbols located in the leaves, it suffices to find the path from the root down to the corresponding leaf assuming that taking the left child represents the 0 bit and the right child represents the 1 bit.

{'a': 0, 'b': 10, 'c': 110, 'd': 111} is a prefix-free code and the correponding full binary tree can be seen in figure~\ref{fig:pfc}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.3\textwidth]{pfc.png}
    \caption{A full binary tree representing a prefix-free code.\label{fig:pfc}}
\end{figure}

\pagebreak

\section{Datatypes}

The inputs of our pipeline are string stored as \lstinline{List[Char]} since it is easier to define recursion on lists rather than on the \lstinline{String} type directly with Stainless. 
Similarily, we define the outputs of our pipeline, an encoded binary string as \lstinline{List[Boolean]}.

We define the following case classes to describe the full binary tree used to represent prefix-free codes and \lstinline{Forest}, which is a list of trees used for the generation of the prefix-free codes:

\begin{lstlisting}
    sealed abstract class Tree
    case class InnerNode(t1: Tree, t2: Tree) extends Tree
    case class Leaf(w: BigInt, c: Char) extends Tree
  
    type Forest = List[Tree]
\end{lstlisting}

Moreover, we define two functions on \lstinline{Tree}s that are proven to be reflexive and transitive:
\begin{itemize}
    \item \lstinline{isSubTree(t: Tree, st: Tree)}: boolean value indicating if \lstinline{st} is a subtree of \lstinline{t}.
    \item \lstinline{isSameTree(t1: Tree, t2: Tree)}: boolean value indicating if two trees are the same, i.e. all the nodes are the same.
\end{itemize}

\section{Encoder}

\subsection{"Encodability"}
Before implementing the \lstinline{encode} function, we need to define the notion of encodability. For a character to be encodable with a given tree, it must appear exactly once its leaves.
If the character does not appear in the tree, we simply cannot encode it and if it appears more than once, the behavior of the function is undefined.

We so define the following function that returns true if and only if the given character appears exactly once in the tree's leaves:

\begin{lstlisting}
    def canEncodeCharUniquely(t: Tree, c: Char): Boolean
\end{lstlisting}

When encoding, we also require that the tree must be an \lstinline{InnerNode} because encoding with a single \lstinline{Leaf} is not properly defined. In fact, there is no point in encoding a string that contains only one unique character.

\subsection{Encode a character}
We first define the following :

\begin{lstlisting}
    def {encodeChar(t: Tree, c: Char): List[Boolean]} 
\end{lstlisting}

It is used to encode the given \lstinline{Char} recursively using the given \lstinline{Tree}. This function also requires the \lstinline{Tree} to be an instance of \lstinline{InnerNode} 
and the \lstinline{Char} to be uniquely encodable :

\begin{enumerate}
    \item It first checks which of the left or right child of the tree contains the character to encode
    \item if the child is a \lstinline{Leaf}, it returns \lstinline{List(False)} if it is the left child or \lstinline{List(True)} if it is the right,
    \item if the child is a \lstinline{InnerNode}, it performs a recursive call on this subtree and appends the result to either \lstinline{List(False)} or \lstinline{List(True)}.
\end{enumerate}

For the first point to be valid, we define the following lemma: if a tree can encode uniquely a character, then exactly one of its children can. We then know that only one branch of the condition is valid at a time.

The function has a post condition asserting that the produced list of bits is actually decodable and that, if it is decoded, it returns the exact same character that is to be encoded and all bits of its encoding are consumed.

\subsection{Encode a string}
We first define the following :

\begin{lstlisting}
    def encode(t: Tree, s: List[Char]): List[Boolean]
\end{lstlisting}

It requires the \lstinline{Tree} to be a \lstinline{InnerNode} and  the \lstinline{List[Char]} to be non-empty and that each of its character is uniquely encodable with the tree.

We now define the \lstinline{encode} function itself. It is defined recursively as follows:
\begin{enumerate}
    \item If there is only one char in the input list, call \lstinline{encodeChar} and returns the result.
    \item Else, call \lstinline{encodeChar} on the head and concatenate the result with the result of a recursive call on the tail.
\end{itemize}

The post condition asserts that the produced list of bits is decodable using the same tree and that, if decoded, gives back the same string as the one received as input.

To prove this postcondition, we have to define the following lemmas:
\begin{enumerate}
    \item Assert that \lstinline{encodeChar} produces a list of bits that is decodable and gives the right result back.
    \item Assert that if we can decode two lists of bits, we can still decode the concatenation of the two.
    \item Assert that if we can decode a list of bits, then we can correctly decode at least one character from it and that we can still decode correcty the remaining bits.
\end{enumerate}

\section{Decoder}

\subsection{"Decodability"}
Similarily to the notion of encodability, we define the notion of decodability. Namely, the two following functions:

\begin{lstlisting}
    def canDecodeAtLeastOneChar(t: Tree, bs: List[Boolean]): Boolean
    def canDecode(s: Tree, bs: List[Boolean])
                 (implicit t: Tree): Boolean
\end{lstlisting}

The first one returns true if it is possible to decode at least one character from the given list of bits using the given tree. 
It goes down the tree from the root and follow the proper edge recursively given the head bit of the list and consumes it. If it reaches a leaf, it returns true or false otherwise.

The second one returns true only if we can decode the whole list of bits, i.e. we can decode one or more characters and when the list of bits is empty, we eventually reached a leaf. It is defined recursively and uses \lstinline{canDecodeAtLeastOneChar}.

Then, we prove a few lemmas related to those two functions, the most important ones being the following:
\begin{itemize}
    \item \lstinline{canDecodeImpliesCanDecodeAtLeastOneChar}: proves that, if we can decode the whole list of bits, then we can decode at least one character from it.
    \item \lstinline{canDecodeImpliesCanDecodeTailAfterOneCharDecoded}: proves that, if we can decode the whole list of bits, then if we decode the first character, we can still decode the remaining bits.
\end{itemize}

\subsection{Decode a character}
Just as for the \lstinline{encode} function, we first define a function to decode on character. This \lstinline{decodeChar} function takes as parameters a \lstinline{List[Boolean]} and 
a \lstinline{Tree} and produces a tuple containing the decoded \lstinline{Char} and the remaining \lstinline{List[Boolean]}.
As preconditions, it requires that the given \lstinline{Tree} is in fact a \lstinline{InnerNode} (as \lstinline{encode} does and for the same reasons) and that we can decode at least one character from the given list of bits using the given tree.

Concerning the implementation, it is define recursively: it goes down the tree consuming a bit from the list at each step (when \lstinline{False} it calls recursively on the left child, on the right when \lstinline{True}) until it reaches a leaf. At this point,
it returns the character that is in the leaf and the remaining list of bits.

\subsection{Decode a string}
The \lstinline{decode} function takes as parameters a \lstinline{List[Boolean]} and a \lstinline{Tree} and produces a \lstinline{List[Char]}. The output corresponds to the list of characters obtained by decoding the list of bits using the given tree.
It has no postcondition but some preconditions. As \lstinline{decodeChar}, it requires that the given \lstinline{Tree} is a \lstinline{InnerNode} but also that we can decode the entire given list of bits using the given tree.

Concerning the implementation, it first calls \lstinline{decodeChar} and if the remaining list of bits in the resulting tuple is empty, it returns \lstinline{List(c)} where \lstinline{c} is the character in the tuple. If the remaining bits list is not empty,
it calls itself recursively on this list and returns \lstinline{c :: res)} where res is the list produced by the recursive call.

The lemmas are called in the implementation to ensure that the preconditions of the calls to \lstinline{decodeChar} and to \lstinline{decode} are indeed valid.


\section{Prefix-free code generator} %TODO
To complete the pipeline, we implement a algorithm that produces a prefix-free code for a string. It is a naive algorithm in the sense that it does not produce an optimal tree 
(optimal in the sense that the encoded string is the shortest possible given the input).

It takes as parameters a \lstinline{List[Char]} and works as following:
\begin{itemize}
    \item a function produces a \lstinline{List[(Char, Int)]} where each character of the input list appears once and the integer in the tuple is the number of times this character occurs in the input list. We call this list the occurences.
    \item a function takes the occurences and produces a \lstinline{Forest} of leaves where each character appears in one leaf with the number of occurences as weight.
    \item the tree is then produced by recursively merging the two first trees of the forest into a new \lstinline{InnerNode} and calling the function recursively on the resulting \lstinline{Forest} until only one tree is left.
\end{itemize}

To implement this algorithm, we use three functions:
\begin{lstlisting}
    def generateOccurrences(chars: List[Char])(implicit s: List[Char]): List[(Char, BigInt)]
    def generateForest(s: List[Char]): Forest
    def naivePrefixFreeCode(f: Forest)(implicit s: List[Char]): Tree
\end{lstlisting}

These three functions have some pre- and postconditions ensuring during the whole process that, at the end, each character of the input list in uniquely encodable by the produced tree.
This proof is quite tedious and requires to prove that the list of characters is indeed preserved during the whole process but without any duplicates.

\section{Main theorem}
The main theorem we prove is the following:
\begin{lstlisting}
    def decodeEncodedString(s: List[Char]): Unit = {
    require(removeDuplicates(s).length > 1)
  }.ensuring(_ => {
    val t = generatePrefixFreeCode(s)
    val e = encode(t, s)
    val d = decode(t, e)
    s == d
  })
\end{lstlisting}

It states that, if we take the input string, generate a prefix-free code tree, use it to encode the list and decode the produced encoding, we indeed get back the original list.

\section{Future work}

Huffman's algorithm was the starting point of this project altough we did not clearly exploit it. We restricted ourselves to the broader class of prefix-free codes and how to generate some without worrying about its optimality as in \cite{blanchette}. 

As an improvement, we suggest to extend our current implementation of naive prefix-free code generator to an actual formally verified implementation of Huffman's algorithm. This is surely more challenging to prove since Huffman's algorithm requires sorting the forest of tree at each iteration. Ensuring the forest properties such as the characters that can be uniquely decoded with it, is not trivial.

\section{Conclusion}
We propose a formally verified implementation in Scala of a pair of encode/decode functions for prefix-free code. To complete the pipeline, we also propose a formally verified prefix-free code generator although not optimal.
We verify the whole pipeline, that means that, given a string represented by a \lstinline{List[Char]}, it can generate the prefix-free code, encode the string and decode the encoded output correctly.

The most difficult part of this project is to figure out how to break problems into pieces small enough so that Stainless can prove them. 
It is quite frustrating to see how trivial the solution appears but how difficult it is to find it in the first place.


\vspace{0.5cm} % some vertical space since we are creating this paragraph manually
\noindent % otherwise many styles like to indent the first word of a paragraph
\textbf{\large Acknowledgements.}\ % Bold, large font
The autors of this report would like to thank Viktor Kun\v{c}ak for proposing such course at EPFL and offering to get some experience with a personal project they truly enjoyed to work on. The autors thank Jad Hamza, who was often able to provide precious help for the progress of the project despite the lack of context.

% =======================================================================================

\bibliography{main} % this will make bibliography appear

\end{document}
