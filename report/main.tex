\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
\usepackage{xspace}
\usepackage{graphicx} % For \includegraphics
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory
\usepackage{amsmath}
\bibliographystyle{plainurl}% the bibstyle
\usepackage{cleveref} % Provides \Cref
\usepackage{listings} % For code snippets


\title{Implementation and verification of an encoder decoder pair and generator for prefix-free codes}

\author{Samuel Chassot}{EPFL}{samuel.chassot@epfl.ch}{}{}
\author{Daniel Filipe Nunes Silva}{EPFL}{daniel.nunessilva@epfl.ch}{}{}

\authorrunning{S.~Chassot and D.~F.~Nunes~Silva}

\Copyright{Samuel Chassot and Daniel Filipe Nunes Silva}

\ccsdesc[500]{Software and its engineering~Software verification and validation}

\keywords{formal verification, prefix-free codes, Huffman Coding}

\category{}
\relatedversion{}
\supplement{}
\nolinenumbers 
\hideLIPIcs

\begin{document}

\maketitle

\begin{abstract}
    Prefix-free codes are widely used in communication systems, e.g. in compression algorithms combined with Huffman's algorithm. In this work, we propose an implementation in the Scala programming language of an encoder decoder pair as well as a naive prefix-free code generator. Such implementations can be critical due to the fundamental role they play. Therefore, our implementations are formally proven for correctness thanks to the verification framework Stainless \cite{stainless}. Those three functions can be chained to form a pipeline as a whole on a given input string $s$, i.e. generate a correspoding prefix-free code $c$, use $c$ to encode $s$ as $e$ and finally decode $e$ with $c$ as $d$. Correctness is therefore defined as $s == d$.
\end{abstract}

\definecolor{bgcolor}{RGB}{240,252,210}
\definecolor{kwcolor}{RGB}{0,0,200}
\lstdefinelanguage{scala}{
  keywordstyle=\color{kwcolor},
  backgroundcolor=\color{bgcolor},
  alsoletter={@,=,>},
  morekeywords={abstract, case, class, def,
        else, extends, false, free, if, implicit, match,
        object, true, val, var, while, sealed,
        for, dependent, null, type, with, try, catch, finally,
        import, final, return, new, override, this, trait,
        private, public, protected, package, throw},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  mathescape=true,
  %emph={Int,Char,Boolean,String,Unit},
  %emphstyle={\color{blue}}
}
\lstset{language=scala}


\section{Introduction}
\label{sec:intro}

The aim of this project is to come up with a verified implementation of an encoder decoder pair as well as a prefix-free code generator in the scope of a personal project for the Formal Verification course (CS-550) at EPFL.

In \cite{blanchette}, J. C. Blanchette presents a formal proof of the optimality of the Huffman's algorithm. The latter generates a prefix-free code for a string such that the encoding of the encoded string has minimal length. As proposed in the conclusion of Blanchette's article, we explore the verification of encode/decode functions.

In this report, we start with some background knowledge related to prefix-free codes. Then, we go through the verified implementation of the pipeline we propose.

\subsection*{Prior work}

To the best of our knowledge, this is the first time an encode/decode function pair is formally verified.
However we can find many examples of similar exercises in the litterature such as a formal definition Huffman's algorithm in \cite{formal} or a formally verified implemention of compression/decompression function pair for deflate in \cite{deflate}.

\subsection*{Our approach} % the star makes the section number disappear

We first consider the whole class of prefix-free codes and not only the optimal ones generated by Huffman's algorithm.
Then, we come up with basic datatypes and implementations in vanilla Scala before adding  \emph{require}s and \emph{ensuring}s from Stainless in order to validate the main correctness theorem.
Finally, we also implement and verify an naive prefix-free code generator in order to complete the whole pipeline.

\pagebreak

\subsection*{Contributions} % the star makes the section number disappear

The main contributions of this report are the following:
\begin{enumerate}
    \item a formally verified implementation of an encode decode pair for prefix-free codes
    \item a formally verified implementation of a prefix-free code generator
\end{enumerate}

\section{Implementation}

Our code is available in the following repository:
\begin{center}
    \url{https://github.com/samuelchassot/FormalVerification-PrefixFreeCodes}
\end{center}
and build instructions are in file \verb|README.md| in the top-level directory.

\section{Prefix-free codes}

We define a code as a map from characters formed from a string, the symbols, to a list of bits, the code words. The fact that a code is prefix-free means that there is no full code word in this map that is a prefix of an other code word, e.g. $01$ is a prefix of the code word $0111$.

Those codes can be represented as full binary trees. To determine the code word of a symbols located in the leaves, it suffices to find the path from the root down to the corresponding leaf assuming that taking the left child represents the 0 bit and the right child represents the 1 bit.

{'a': 0, 'b': 10, 'c': 110, 'd': 111} is a prefix-free code and the correponding full binary tree can be seen in figure~\ref{fig:pfc}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.3\textwidth]{pfc.png}
    \caption{A full binary tree representing a prefix-free code.\label{fig:pfc}}
\end{figure}

\section{Datatypes}

The inputs of our pipeline are string stored as \lstinline{List[Char]} since it is easier to define recursion on lists rather than on the \lstinline{String} type directly with Stainless. 
Similarily, the outputs of our pipeline, an encoded binary string are defined as \lstinline{List[Boolean]}.

We define the following case classes to describe the full binary tree used to represent prefix-free codes and \lstinline{Forest}, which is a list of trees used for the generation of the prefix-free codes:

\begin{lstlisting}
    sealed abstract class Tree
    case class InnerNode(t1: Tree, t2: Tree) extends Tree
    case class Leaf(w: BigInt, c: Char) extends Tree
  
    type Forest = List[Tree]
\end{lstlisting}

On the one hand, we use \lstinline{InnerNode}s representing the intermediates nodes from the root down to the leaves and they are fully defined by their two children. On the other hand, we have \lstinline{Leaf} to describe the bottom nodes. Those contain the character \lstinline{c} they represent as well as their correspoding weight \lstinline{w}, i.e. how many time it appears in the corresponding string.

Moreover, we define two functions on \lstinline{Tree}s that are proven to be reflexive and transitive:
\begin{itemize}
    \item \lstinline{isSubTree(t: Tree, st: Tree)}: boolean value indicating if \lstinline{st} is a subtree of \lstinline{t}.
    \item \lstinline{isSameTree(t1: Tree, t2: Tree)}: boolean value indicating if two trees are the same, i.e. all the nodes are the same.
\end{itemize}

\section{Encoder}

\subsection{``Encodability''}
Before implementing the \lstinline{encode} function, we need to define the notion of encodability. For a character to be encodable with a given tree, it must appear exactly once in its leaves.
If the character does not appear in the tree, we simply cannot encode it and if it appears more than once, the behavior of the function is undefined.

We therefore define the following function that returns true if and only if the given character appears exactly once in the tree's leaves:

\begin{lstlisting}
    def canEncodeCharUniquely(t: Tree, c: Char): Boolean
\end{lstlisting}

When encoding, we also require that the tree is an \lstinline{InnerNode} because encoding with a single \lstinline{Leaf} is not properly defined. In fact, there is no point in encoding a string that contains only one unique character.

\subsection{Encode a character}
We first define the following :

\begin{lstlisting}
    def {encodeChar(t: Tree, c: Char): List[Boolean]} 
\end{lstlisting}

It is used to encode the given \lstinline{Char} recursively using the given \lstinline{Tree}. This function also requires the \lstinline{Tree} to be an instance of \lstinline{InnerNode} 
and the \lstinline{Char} to be uniquely encodable :

\begin{enumerate}
    \item It first checks which of the left or right child of the tree contains the character to encode
    \item if the child is a \lstinline{Leaf}, it returns \lstinline{List(False)} if it is the left child or \lstinline{List(True)} if it is the right,
    \item if the child is a \lstinline{InnerNode}, it performs a recursive call on this subtree and appends the output to either \lstinline{List(False)} or \lstinline{List(True)}.
\end{enumerate}

For the first point to be valid, we define the following lemma: if a tree can encode uniquely a character, then exactly one of its children can. We then know that only one branch of the condition is valid at a time.

The function has a postcondition asserting that the produced list of bits is actually decodable and that, if it is decoded, it returns the exact same character that is to be encoded and all bits of its encoding are consumed.

\subsection{Encode a string}
We first define the following :

\begin{lstlisting}
    def encode(t: Tree, s: List[Char]): List[Boolean]
\end{lstlisting}

It requires the \lstinline{Tree} to be a \lstinline{InnerNode} and  the \lstinline{List[Char]} to be non-empty and that each of its character is uniquely encodable with the tree.

We now define the \lstinline{encode} function itself. It is defined recursively as follows:
\begin{enumerate}
    \item If there is only one char in the input list, call \lstinline{encodeChar} and returns the result.
    \item Else, call \lstinline{encodeChar} on the head and concatenate the result with the result of a recursive call on the tail.
\end{enumerate}

The postcondition asserts that the produced list of bits is decodable using the same tree and that, if decoded, gives back the same string as the one received as input.

To prove this postcondition, we have to define the following lemmas:
\begin{enumerate}
    \item Assert that \lstinline{encodeChar} produces a list of bits that is decodable and gives the right result back.
    \item Assert that if we can decode two lists of bits, we can still decode the concatenation of the two.
    \item Assert that if we can decode a list of bits, then we can correctly decode at least one character from it and that we can still decode correcty the remaining bits.
\end{enumerate}

\section{Decoder}

\subsection{``Decodability''}
Similarily to the notion of encodability, we define the notion of decodability. Namely, the two following functions:

\begin{lstlisting}
    def canDecodeAtLeastOneChar(t: Tree, bs: List[Boolean]): Boolean
    def canDecode(s: Tree, bs: List[Boolean])
                 (implicit t: Tree): Boolean
\end{lstlisting}

The first one returns true if it is possible to decode at least one character from the given list of bits using the given tree. 
It goes down the tree from the root and follows the proper edge recursively given the head bit of the list and consumes it. If it reaches a leaf it returns true. 
This means that given the bits to decode a character from, you could actually find a path from the root of the tree to a character. If it does not reach a leaf, 
it is eventually stuck in ``the middle of the tree'' with no more bits to consume. In this case, the function returns false since the provided bits were not enough to decode at least one character from.

The second one returns true only if we can decode the whole list of bits, i.e. we can decode one or more characters and when the list of bits is empty, we effectively reached a leaf. It is defined recursively and uses \lstinline{canDecodeAtLeastOneChar}.

Then, we prove a few lemmas related to those two functions, the most important ones being the following:
\begin{itemize}
    \item \lstinline{canDecodeImpliesCanDecodeAtLeastOneChar}: proves that, if we can decode the whole list of bits, then we can decode at least one character from it.
    \item \lstinline{canDecodeImpliesCanDecodeTailAfterOneCharDecoded}: proves that, if we can decode the whole list of bits, then if we decode the first character, we can still decode the remaining bits.
\end{itemize}

\subsection{Decode a character}
We first define the following :

\begin{lstlisting}
    def decodeChar(t: Tree, bs: List[Boolean]): (Char, List[Boolean])
\end{lstlisting}

It produces a tuple containing the decoded \lstinline{Char} and the remaining \lstinline{List[Boolean]} to be decoded.
As preconditions, it requires that the given \lstinline{Tree} is in fact an \lstinline{InnerNode} and that we can decode at least one character from the given list of bits using the given tree.

Concerning the implementation, it is defined recursively: going down the tree consuming a bit from the list at each step, when \lstinline{False} it calls recursively on the left child or on the right one when \lstinline{True} until it reaches a leaf. At this point,
it returns the character that is in the leaf and the remaining list of bits.

\subsection{Decode a string}
We first define the following :

\begin{lstlisting}
    def decode(t: Tree, bs: List[Boolean]): List[Char]
\end{lstlisting}

The output corresponds to the list of characters obtained by decoding the list of bits using the given tree if it was indeed decodable, \lstinline{Nil()} otherwise.
Like \lstinline{decodeChar}, it requires the given \lstinline{Tree} to be an \lstinline{InnerNode}. It has no postcondition. 

Concerning the implementation, it first checks if the list of bits is decodable using the given tree by calling \lstinline{canDecode}: if it is not the case, it returns \lstinline{Nil()}. 
If it is indeed decodable, it calls \lstinline{decodeChar} and if the remaining list of bits in the resulting tuple is empty, it returns \lstinline{List(c)} where \lstinline{c} is the character in the tuple. If the remaining bits list is not empty,
it calls itself recursively on this list and returns \lstinline{c :: res} where res is the list produced by the recursive call.

By testing that the given list of bits is decodable instead of requiring it as precondition, we ensure that it is possible to call decode on an incorrect list of bits. 
In this way, if this pair of functions is actually used by users, a user can try to decode a list of bits that someone else sent to her. The user has to send the tree along with the list of bits so that someone else can decode it.

The lemmas are called in the implementation to ensure that the preconditions of the calls to \lstinline{decodeChar} and to \lstinline{decode} are indeed valid.

\section{Prefix-free code generator} 
To complete the pipeline, we implement an algorithm that produces a prefix-free code for a string. It is a naive algorithm in the sense that it does not produce an optimal such that the encoded string is the shortest possible given the input.

It takes as parameters a \lstinline{List[Char]} and works as following:
\begin{enumerate}
    \item A function produces a \lstinline{List[(Char, Int)]} where each character of the input list appears once and the integer in the tuple is the number of times this character occurs in the input list. We call this list the occurences.
    \item A function takes the occurences and produces a \lstinline{Forest} of leaves where each character appears in one leaf with the number of occurences as weight.
    \item The tree is then produced by recursively merging the two first trees of the forest into a new \lstinline{InnerNode} and calling the function recursively on the resulting \lstinline{Forest} until only one tree is left.
\end{enumerate}

To implement this algorithm, we use three functions:
\begin{lstlisting}
    def generateOccurrences(chars: List[Char])
                           (implicit s: List[Char]): List[(Char,
                                                           BigInt)]
    def generateForest(s: List[Char]): Forest
    def naivePrefixFreeCode(f: Forest)(implicit s: List[Char]): Tree
\end{lstlisting}

These three functions have sufficient pre- and postconditions ensuring during the whole process that,  each character of the input list in uniquely encodable by the produced tree.
This proof is not trivial and requires to prove that the list of characters is indeed preserved during the whole process but without any duplicates.

\section{Main theorem}
The main theorem we prove in the end is the following:
\begin{lstlisting}
    def decodeEncodedString(s: List[Char]): Unit = {
        require(removeDuplicates(s).length > 1)
    }.ensuring(_ => {
        val t = generatePrefixFreeCode(s)
        val e = encode(t, s)
        val d = decode(t, e)

        s == d
    })
\end{lstlisting}

It states that, if we take the input string, generate a prefix-free code tree, use it to encode the list and decode the produced encoding, we indeed get back the original list.

\section{Future work}

Huffman's algorithm was the starting point of this project although we did not clearly exploit it. We restricted ourselves to the broader class of prefix-free codes and how to generate some without worrying about its optimality as in \cite{blanchette}. 

As an improvement, we suggest to extend our current implementation of naive prefix-free code generator to an actual formally verified implementation of Huffman's algorithm. This is surely more challenging to prove since Huffman's algorithm requires sorting the forest of tree at each iteration. Ensuring the forest properties such as the characters that can be uniquely decoded with it, is not trivial.

We could also explore how to adapt our work to different kind of codes. In fact, how could this work with the broader class of uniquely decodable codes. 
The main challenge would probably be to come up with an elegant way of representing such codes. 
In our case, representing prefix-free codes as full binary trees gave us a nice advantages, e.g. they allow recursion which is natural to work with in Stainless.

\section{Conclusion}
We propose a formally verified implementation in Scala of an encode-decode functions pair for prefix-free code. To complete the pipeline, we also propose a formally verified prefix-free code generator.
We verify the whole pipeline, that means that, given a string represented by a \lstinline{List[Char]}, it can generate the prefix-free code, encode the string and decode the encoded output correctly.

The most difficult part of this project is to figure out how to break problems into pieces small enough so that Stainless can be used to prove them. 
It is frustrating to see how trivial the solution appears but how difficult it is to find it in the first place.

\vspace{0.5cm} % some vertical space since we are creating this paragraph manually
\noindent % otherwise many styles like to indent the first word of a paragraph
\textbf{\large Acknowledgements.}\ % Bold, large font
The autors of this report would like to thank Viktor Kun\v{c}ak for proposing such course at EPFL and offering to get some experience with a personal project they truly enjoyed to work on. The autors thank Jad Hamza, who was often able to provide precious help for the progress of the project despite the lack of context.

% =======================================================================================

\bibliography{main} % this will make bibliography appear

\end{document}
